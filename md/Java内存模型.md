# Java内存模型
@(深入理解Java)[内存模型,Java]

[JVM内存结构 VS Java内存模型 VS Java对象模型](http://www.hollischuang.com/archives/2509)
[再有人问你Java内存模型是什么，就把这篇文章发给他。](http://www.hollischuang.com/archives/2550)


**`Java内存模型(JMM)`规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为`Java内存模型`。**

> 注意和`Java运行时内存`区分开。

想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型**规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。**

<br>

-------

## Java内存模型内部原理

![|left](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png)![|right](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png)

第一张图演示了Java内存模型吧Java虚拟机内部划分为线程栈和堆。（具体就不细讲了，可以看`Java运行时内存`）

第二张图演示了调用栈的本地变量放在线程栈上，对象放在堆上。

我们从`Java运行时内存`知道，线程栈上只能存储`boolean,byte,char,short,int,float,reference,returnAddress`这些类型。

总结一下：
- 一个本地变量可能是基本类型，在这种情况下，它总是“呆在”线程栈上。

- 一个本地变量也可能是指向一个对象的一个引用`reference`。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。

- 一个对象可能包含方法(这个方法又可以看做是一个新的线程栈帧)，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。

- 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。

- 静态成员变量跟随着类定义一起也存放在堆上。

- 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时使用同一个对象上的同一个成员变量，它们将会都拥有这个成员变量的私有拷贝。

<br>

> **上文说的本地变量就存放在Java虚拟机栈线程帧栈中的局部变量表中**


如下图所示：

![|center](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png)

两个线程拥有一些的本地变量。其中一个本地变量（Local Variable 2）指向堆上的一个共享对象（Object 3）。这两个线程分别拥有同一个对象的不同引用。这些引用都是本地变量，因此存放在各自线程的方法帧栈上的局部变量表中。这两个不同的引用指向堆上同一个对象。

![|center](http://ifeve.com/wp-content/uploads/2013/01/113.png)

比如说Object4是Object3的一个基本类型的成员变量，两个线程的methodOne都要去访问这个变量，那么在两个线程的methodOne方法帧栈的局部变量表中，都会存在该成员变量的一份拷贝。而这一份存在虚拟机栈中的方法帧栈中的局部变量表中的本地变量对其他线程都是不可见的，直到刷新回主存（也就是堆内存），再被其他线程访问时，才能看到该值被修改了。所以如果这时候一个线程从堆内存上读到本地变量中，在刷新回主存之前另一个线程又去读取并修改并刷回主存，就出现了多线程操作导致数据不一致的情况。


<br>
**`如何保证线程修改对其他线程的可见性`**

说白了就是 如何保证线程修改了主内存（堆）的内容及时刷新回主内存上，在其他线程访问的时候，能读到最新的值得问题。

在Java中提供了两种方案：
- `volatile` 使用volatile声明的成员变量，对他的修改会立刻同步到主存上，就是说可以保证，这次修改之后发生的读操作，一定能读到被修改之后的值
- `synchronize` 同步块。同步块保证，同一时间只能有一个线程进入，并且在退出同步块之前，需要把数据同步回主存。


<br>

---------

## 硬件内存架构

现代硬件内存模型与Java内存模型有一些不同。理解内存模型架构以及Java内存模型如何与它协同工作也是非常重要的。这部分描述了通用的硬件内存架构，下面的部分将会描述Java内存是如何与它“联手”工作的

下面是现代计算机硬件架构的简单图示：

![|center](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png)

一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。

每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。

每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。一些CPU还有多层缓存。

通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。


<br>

---------

## Java内存模型和硬件内存架构之间的桥接

上面已经提到，Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：

![|center](http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png)



<br>

---------

参考自：
1. [Java内存模型](http://ifeve.com/java-memory-model-6/)

