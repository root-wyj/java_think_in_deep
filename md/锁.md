# 锁
@(深入理解Java)[并发,多线程,concurrenct,lock,锁]


<br>

----------

## 死锁

<br>

### 导致死锁的原因

<br>

`情况一`

因为不同的加锁顺序。A线程对锁a,b 先a再b；B线程对锁a,b 先b再a。很容易导致死锁。

```plain
Thread 1: parent.addChild(child); //locks parent
          --> child.setParentOnly(parent);

Thread 2: child.setParent(parent); //locks child
          --> parent.addChildOnly()
```

<br>

`情况二`

比情况一更复杂的情况：

```plain
Thread 1  locks A, waits for B
Thread 2  locks B, waits for C
Thread 3  locks C, waits for D
Thread 4  locks D, waits for A
```

这种情况不是简单的锁的顺序的不同，是多处加锁，因为锁之间的关系还有业务关系比较复杂导致的。这种就要具体情况具体分析了。

<br>

`情况三`

数据库的死锁

```plain
Transaction 1, request 1, locks record 1 for update
Transaction 2, request 1, locks record 2 for update
Transaction 1, request 2, tries to lock record 2 for update.
Transaction 2, request 2, tries to lock record 1 for update.
```

这种情况很大可能也是因为在操作多张表的时候，操作顺序不一致导致的。


<br>

----------

### 避免死锁

<br>

**`统一加锁顺序`**

这种方式是事先知道有哪些锁，然后通过控制这些锁的加锁顺序，防止发生死锁。

<br>

**`加锁超时`**

是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行。

由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。

如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。

Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。


<br>

**`死锁检测`**

死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。

每当**一个线程获得了锁，会在线程和锁相关的数据结构中**（map、graph等等）将其记下。除此之外，每当**有线程请求锁，也需要记录在这个数据结构中**。

当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。

下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁

![|center](http://ifeve.com/wp-content/uploads/2013/03/deadlock-detection-graph.png)

**如果发生了死锁怎么办**

一个可行的做法是**释放所有锁，回退，并且等待一段随机的时间后重试**。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是**如果有大量的线程竞争同一批锁，它们还是会重复地死锁**

一个更好的方案是给这些**线程设置优先级**，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的**优先级是固定不变的，同一批线程总是会拥有更高的优先级，导致线程饥饿。为避免这个问题，可以在死锁发生的时候设置随机的优先级**。


<br>

---------

## 公平锁 FairLock

如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为`公平性` – 即所有线程均能公平地获得运行机会。

<br>

**`Java中导致饥饿的原因`**

- 高优先级线程吞噬所有的低优先级线程的CPU时间。
 你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多
 对大多数应用来说，最好是不要改变其优先级值。
- 线程被永久堵塞在一个等待进入同步块的状态。
 Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。所以就有可能出现其他线程总是能优先某个线程访问到锁资源，所以也永远得不到CPU运行的机会，导致饥饿。
- wait 永远不被唤醒
 多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。


<br>

**`Java中实现公平性需要注意`**

- 使用锁，而不是同步块。
- 公平锁。
- 注意性能方面。

<br>

---------------




<br>

---------

## 可重入锁 ReentrantLock




<br>

---------

## 读写锁 ReadWriteLock




<br>

-------

## 锁优化


[深入理解多线程（五）—— Java虚拟机的锁优化技术](http://www.hollischuang.com/archives/2344)

[聊聊并发（二）Java SE1.6中的Synchronized](http://ifeve.com/java-synchronized/)